{"/home/travis/build/npmtest/node-npmtest-applicationinsights/test.js":"/* istanbul instrument in package npmtest_applicationinsights */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/lib.npmtest_applicationinsights.js":"/* istanbul instrument in package npmtest_applicationinsights */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_applicationinsights = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_applicationinsights = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-applicationinsights && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_applicationinsights */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_applicationinsights\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_applicationinsights.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_applicationinsights.rollup.js'] =\n            local.assetsDict['/assets.npmtest_applicationinsights.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_applicationinsights.__dirname + '/lib.npmtest_applicationinsights.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/applicationinsights.js":"\"use strict\";\r\nvar CorrelationContextManager = require(\"./AutoCollection/CorrelationContextManager\"); // Keep this first\r\nvar AutoCollectConsole = require(\"./AutoCollection/Console\");\r\nvar AutoCollectExceptions = require(\"./AutoCollection/Exceptions\");\r\nvar AutoCollectPerformance = require(\"./AutoCollection/Performance\");\r\nvar AutoCollectClientRequests = require(\"./AutoCollection/ClientRequests\");\r\nvar AutoCollectServerRequests = require(\"./AutoCollection/ServerRequests\");\r\nvar Client = require(\"./Library/Client\");\r\nvar Logging = require(\"./Library/Logging\");\r\n/**\r\n * The singleton meta class for the default client of the client. This class is used to setup/start and configure\r\n * the auto-collection behavior of the application insights module.\r\n */\r\nvar ApplicationInsights = (function () {\r\n    function ApplicationInsights() {\r\n    }\r\n    /**\r\n     * Initializes a client with the given instrumentation key, if this is not specified, the value will be\r\n     * read from the environment variable APPINSIGHTS_INSTRUMENTATIONKEY\r\n     * @returns {ApplicationInsights/Client} a new client\r\n     */\r\n    ApplicationInsights.getClient = function (instrumentationKey) {\r\n        return new Client(instrumentationKey);\r\n    };\r\n    /**\r\n     * Initializes the default client of the client and sets the default configuration\r\n     * @param instrumentationKey the instrumentation key to use. Optional, if this is not specified, the value will be\r\n     * read from the environment variable APPINSIGHTS_INSTRUMENTATIONKEY\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.setup = function (instrumentationKey) {\r\n        if (!ApplicationInsights.client) {\r\n            ApplicationInsights.client = ApplicationInsights.getClient(instrumentationKey);\r\n            ApplicationInsights._console = new AutoCollectConsole(ApplicationInsights.client);\r\n            ApplicationInsights._exceptions = new AutoCollectExceptions(ApplicationInsights.client);\r\n            ApplicationInsights._performance = new AutoCollectPerformance(ApplicationInsights.client);\r\n            ApplicationInsights._serverRequests = new AutoCollectServerRequests(ApplicationInsights.client);\r\n            ApplicationInsights._clientRequests = new AutoCollectClientRequests(ApplicationInsights.client);\r\n        }\r\n        else {\r\n            Logging.info(\"The default client is already setup\");\r\n        }\r\n        if (ApplicationInsights.client && ApplicationInsights.client.channel) {\r\n            ApplicationInsights.client.channel.setOfflineMode(ApplicationInsights._isOfflineMode);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Starts automatic collection of telemetry. Prior to calling start no telemetry will be collected\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.start = function () {\r\n        if (!!this.client) {\r\n            ApplicationInsights._isStarted = true;\r\n            ApplicationInsights._console.enable(ApplicationInsights._isConsole);\r\n            ApplicationInsights._exceptions.enable(ApplicationInsights._isExceptions);\r\n            ApplicationInsights._performance.enable(ApplicationInsights._isPerformance);\r\n            ApplicationInsights._serverRequests.useAutoCorrelation(ApplicationInsights._isCorrelating);\r\n            ApplicationInsights._serverRequests.enable(ApplicationInsights._isRequests);\r\n            ApplicationInsights._clientRequests.enable(ApplicationInsights._isDependencies);\r\n        }\r\n        else {\r\n            Logging.warn(\"Start cannot be called before setup\");\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Returns an object that is shared across all code handling a given request. This can be used similarly to thread-local storage in other languages.\r\n     * Properties set on this object will be available to telemetry processors.\r\n     *\r\n     * Do not store sensitive information here.\r\n     * Custom properties set on this object can be exposed in a future SDK release via outgoing HTTP headers.\r\n     * This is to allow for correlating data cross-component.\r\n     *\r\n     * This method will return null if automatic dependency correlation is disabled.\r\n     * @returns A plain object for request storage or null if automatic dependency correlation is disabled.\r\n     */\r\n    ApplicationInsights.getCorrelationContext = function () {\r\n        if (this._isCorrelating) {\r\n            return CorrelationContextManager.CorrelationContextManager.getCurrentContext();\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Returns a function that will get the same correlation context within its function body as the code executing this function.\r\n     * Use this method if automatic dependency correlation is not propagating correctly to an asynchronous callback.\r\n     */\r\n    ApplicationInsights.wrapWithCorrelationContext = function (fn) {\r\n        return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn);\r\n    };\r\n    /**\r\n     * Sets the state of console tracking (enabled by default)\r\n     * @param value if true console activity will be sent to Application Insights\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.setAutoCollectConsole = function (value) {\r\n        ApplicationInsights._isConsole = value;\r\n        if (ApplicationInsights._isStarted) {\r\n            ApplicationInsights._console.enable(value);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Sets the state of exception tracking (enabled by default)\r\n     * @param value if true uncaught exceptions will be sent to Application Insights\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.setAutoCollectExceptions = function (value) {\r\n        ApplicationInsights._isExceptions = value;\r\n        if (ApplicationInsights._isStarted) {\r\n            ApplicationInsights._exceptions.enable(value);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Sets the state of performance tracking (enabled by default)\r\n     * @param value if true performance counters will be collected every second and sent to Application Insights\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.setAutoCollectPerformance = function (value) {\r\n        ApplicationInsights._isPerformance = value;\r\n        if (ApplicationInsights._isStarted) {\r\n            ApplicationInsights._performance.enable(value);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Sets the state of request tracking (enabled by default)\r\n     * @param value if true requests will be sent to Application Insights\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.setAutoCollectRequests = function (value) {\r\n        ApplicationInsights._isRequests = value;\r\n        if (ApplicationInsights._isStarted) {\r\n            ApplicationInsights._serverRequests.enable(value);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Sets the state of dependency tracking (enabled by default)\r\n     * @param value if true dependencies will be sent to Application Insights\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.setAutoCollectDependencies = function (value) {\r\n        ApplicationInsights._isDependencies = value;\r\n        if (ApplicationInsights._isStarted) {\r\n            ApplicationInsights._clientRequests.enable(value);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Sets the state of automatic dependency correlation (enabled by default)\r\n     * @param value if true dependencies will be correlated with requests\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.setAutoDependencyCorrelation = function (value) {\r\n        ApplicationInsights._isCorrelating = value;\r\n        if (ApplicationInsights._isStarted) {\r\n            ApplicationInsights._serverRequests.useAutoCorrelation(value);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n    * Enable or disable offline mode to cache events when client is offline (disabled by default)\r\n    * @param value if true events that occured while client is offline will be cached on disk\r\n    * @param resendInterval. The wait interval for resending cached events.\r\n    * @returns {ApplicationInsights} this class\r\n    */\r\n    ApplicationInsights.setOfflineMode = function (value, resendInterval) {\r\n        ApplicationInsights._isOfflineMode = value;\r\n        if (ApplicationInsights.client && ApplicationInsights.client.channel) {\r\n            ApplicationInsights.client.channel.setOfflineMode(value, resendInterval);\r\n        }\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Enables verbose debug logging\r\n     * @returns {ApplicationInsights} this class\r\n     */\r\n    ApplicationInsights.enableVerboseLogging = function (enableWarningLogging) {\r\n        if (enableWarningLogging === void 0) { enableWarningLogging = true; }\r\n        Logging.enableDebug = true;\r\n        Logging.disableWarnings = !enableWarningLogging;\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n     * Disables verbose debug and warning logging\r\n     */\r\n    ApplicationInsights.disableConsoleLogging = function () {\r\n        Logging.enableDebug = false;\r\n        Logging.disableWarnings = true;\r\n        return ApplicationInsights;\r\n    };\r\n    /**\r\n      * Disposes the default client and all the auto collectors so they can be reinitialized with different configuration\r\n      */\r\n    ApplicationInsights.dispose = function () {\r\n        ApplicationInsights.client = null;\r\n        ApplicationInsights._isStarted = false;\r\n        if (ApplicationInsights._console) {\r\n            ApplicationInsights._console.dispose();\r\n        }\r\n        if (ApplicationInsights._exceptions) {\r\n            ApplicationInsights._exceptions.dispose();\r\n        }\r\n        if (ApplicationInsights._performance) {\r\n            ApplicationInsights._performance.dispose();\r\n        }\r\n        if (ApplicationInsights._serverRequests) {\r\n            ApplicationInsights._serverRequests.dispose();\r\n        }\r\n        if (ApplicationInsights._clientRequests) {\r\n            ApplicationInsights._clientRequests.dispose();\r\n        }\r\n    };\r\n    ApplicationInsights._isConsole = true;\r\n    ApplicationInsights._isExceptions = true;\r\n    ApplicationInsights._isPerformance = true;\r\n    ApplicationInsights._isRequests = true;\r\n    ApplicationInsights._isDependencies = true;\r\n    ApplicationInsights._isOfflineMode = false;\r\n    ApplicationInsights._isCorrelating = false;\r\n    ApplicationInsights._isStarted = false;\r\n    return ApplicationInsights;\r\n}());\r\nmodule.exports = ApplicationInsights;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/CorrelationContextManager.js":"\"use strict\";\r\nvar Util = require(\"../Library/Util\");\r\nvar CorrelationContextManager = (function () {\r\n    function CorrelationContextManager() {\r\n    }\r\n    /**\r\n     *  Provides the current Context.\r\n     *  The context is the most recent one entered into for the current\r\n     *  logical chain of execution, including across asynchronous calls.\r\n     */\r\n    CorrelationContextManager.getCurrentContext = function () {\r\n        if (!CorrelationContextManager.enabled) {\r\n            return null;\r\n        }\r\n        return Zone.current.get(\"context\");\r\n    };\r\n    /**\r\n     *  A helper to generate objects conforming to the CorrelationContext interface\r\n     */\r\n    CorrelationContextManager.generateContextObject = function (parentId, operationName, operationId) {\r\n        operationId = operationId || Util.newGuid();\r\n        parentId = parentId || operationId;\r\n        if (this.enabled) {\r\n            return {\r\n                operation: {\r\n                    name: operationName,\r\n                    id: operationId,\r\n                    parentId: parentId\r\n                },\r\n                customProperties: {}\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     *  Runs a function inside a given Context.\r\n     *  All logical children of the execution path that entered this Context\r\n     *  will receive this Context object on calls to GetCurrentContext.\r\n     */\r\n    CorrelationContextManager.runWithContext = function (context, fn) {\r\n        if (CorrelationContextManager.enabled) {\r\n            var newZone = Zone.current.fork({\r\n                name: \"AI-\" + ((context && context.operation.parentId) || \"Unknown\"),\r\n                properties: { context: context }\r\n            });\r\n            newZone.run(fn);\r\n        }\r\n        else {\r\n            fn();\r\n        }\r\n    };\r\n    /**\r\n     *  Patches a callback to restore the correct Context when getCurrentContext\r\n     *  is run within it. This is necessary if automatic correlation fails to work\r\n     *  with user-included libraries.\r\n     *\r\n     *  The supplied callback will be given the same context that was present for\r\n     *  the call to wrapCallback.  */\r\n    CorrelationContextManager.wrapCallback = function (fn) {\r\n        if (CorrelationContextManager.enabled) {\r\n            return Zone.current.wrap(fn, \"User-wrapped method\");\r\n        }\r\n        return fn;\r\n    };\r\n    /**\r\n     *  Enables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.enable = function () {\r\n        if (!this.isNodeVersionCompatible()) {\r\n            this.enabled = false;\r\n            return;\r\n        }\r\n        // Load in Zone.js\r\n        require(\"zone.js\");\r\n        // Run patches for Zone.js\r\n        if (!this.hasEverEnabled) {\r\n            this.hasEverEnabled = true;\r\n            this.patchError();\r\n            this.patchTimers([\"setTimeout\", \"setInterval\"]);\r\n            this.patchRedis();\r\n        }\r\n        this.enabled = true;\r\n    };\r\n    /**\r\n     *  Disables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.disable = function () {\r\n        this.enabled = false;\r\n    };\r\n    /**\r\n     *  Reports if the CorrelationContextManager is able to run in this environment\r\n     */\r\n    CorrelationContextManager.isNodeVersionCompatible = function () {\r\n        // Unit tests warn of errors < 3.3 from timer patching. All versions before 4 were 0.x\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return parseInt(nodeVer[0]) > 3 || (parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2);\r\n    };\r\n    // Patch methods that manually go async that Zone doesn't catch\r\n    CorrelationContextManager.requireForPatch = function (module) {\r\n        var req = null;\r\n        try {\r\n            req = require(module);\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n        return req;\r\n    };\r\n    // A good example of patching a third party library to respect context.\r\n    // send_command is always used in this library to send data out.\r\n    // By overwriting the function to capture the callback provided to it,\r\n    // and wrapping that callback, we ensure that consumers of this library\r\n    // will have context persisted.\r\n    CorrelationContextManager.patchRedis = function () {\r\n        var redis = this.requireForPatch(\"redis\");\r\n        if (redis && redis.RedisClient) {\r\n            var orig = redis.RedisClient.prototype.send_command;\r\n            redis.RedisClient.prototype.send_command = function () {\r\n                var args = Array.prototype.slice.call(arguments);\r\n                var lastArg = args[args.length - 1];\r\n                if (typeof lastArg === \"function\") {\r\n                    args[args.length - 1] = Zone.current.wrap(lastArg, \"AI.CCM.patchRedis\");\r\n                }\r\n                else if (lastArg instanceof Array && typeof lastArg[lastArg.length - 1] === \"function\") {\r\n                    // The last argument can be an array!\r\n                    var lastIndexLastArg = lastArg[lastArg.length - 1];\r\n                    lastArg[lastArg.length - 1] = Zone.current.wrap(lastIndexLastArg, \"AI.CCM.patchRedis\");\r\n                }\r\n                return orig.apply(this, args);\r\n            };\r\n        }\r\n    };\r\n    // Zone.js breaks concatenation of timer return values.\r\n    // This fixes that.\r\n    CorrelationContextManager.patchTimers = function (methodNames) {\r\n        methodNames.forEach(function (methodName) {\r\n            var orig = global[methodName];\r\n            global[methodName] = function () {\r\n                var ret = orig.apply(this, arguments);\r\n                ret.toString = function () {\r\n                    if (this.data && typeof this.data.handleId !== 'undefined') {\r\n                        return this.data.handleId.toString();\r\n                    }\r\n                    else {\r\n                        return Object.prototype.toString.call(this);\r\n                    }\r\n                };\r\n                return ret;\r\n            };\r\n        });\r\n    };\r\n    // Zone.js breaks deepEqual on error objects (by making internal properties enumerable).\r\n    // This fixes that by subclassing the error object and making all properties not enumerable\r\n    CorrelationContextManager.patchError = function () {\r\n        var orig = global.Error;\r\n        // New error handler\r\n        function AppInsightsAsyncCorrelatedErrorWrapper() {\r\n            if (!(this instanceof AppInsightsAsyncCorrelatedErrorWrapper)) {\r\n                return AppInsightsAsyncCorrelatedErrorWrapper.apply(Object.create(AppInsightsAsyncCorrelatedErrorWrapper.prototype), arguments);\r\n            }\r\n            orig.apply(this, arguments);\r\n            // getOwnPropertyNames should be a superset of Object.keys...\r\n            // This appears to not always be the case\r\n            var props = Object.getOwnPropertyNames(this).concat(Object.keys(this));\r\n            // Zone.js will automatically create some hidden properties at read time.\r\n            // We need to proactively make those not enumerable as well as the currently visible properties\r\n            for (var i = 0; i < props.length; i++) {\r\n                var propertyName = props[i];\r\n                var hiddenPropertyName = Zone['__symbol__'](propertyName);\r\n                Object.defineProperty(this, propertyName, { enumerable: false });\r\n                Object.defineProperty(this, hiddenPropertyName, { enumerable: false, writable: true });\r\n            }\r\n            return this;\r\n        }\r\n        // Inherit from the Zone.js error handler\r\n        AppInsightsAsyncCorrelatedErrorWrapper.prototype = orig.prototype;\r\n        // We need this loop to copy outer methods like Error.captureStackTrace\r\n        var props = Object.getOwnPropertyNames(orig);\r\n        for (var i = 0; i < props.length; i++) {\r\n            var propertyName = props[i];\r\n            if (!AppInsightsAsyncCorrelatedErrorWrapper[propertyName]) {\r\n                Object.defineProperty(AppInsightsAsyncCorrelatedErrorWrapper, propertyName, Object.getOwnPropertyDescriptor(orig, propertyName));\r\n            }\r\n        }\r\n        global.Error = AppInsightsAsyncCorrelatedErrorWrapper;\r\n    };\r\n    CorrelationContextManager.enabled = false;\r\n    CorrelationContextManager.hasEverEnabled = false;\r\n    return CorrelationContextManager;\r\n}());\r\nexports.CorrelationContextManager = CorrelationContextManager;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Util.js":"\"use strict\";\r\nvar url = require(\"url\");\r\nvar Logging = require(\"./Logging\");\r\nvar Util = (function () {\r\n    function Util() {\r\n    }\r\n    /**\r\n     * helper method to access userId and sessionId cookie\r\n     */\r\n    Util.getCookie = function (name, cookie) {\r\n        var value = \"\";\r\n        if (name && name.length && typeof cookie === \"string\") {\r\n            var cookieName = name + \"=\";\r\n            var cookies = cookie.split(\";\");\r\n            for (var i = 0; i < cookies.length; i++) {\r\n                var cookie = cookies[i];\r\n                cookie = Util.trim(cookie);\r\n                if (cookie && cookie.indexOf(cookieName) === 0) {\r\n                    value = cookie.substring(cookieName.length, cookies[i].length);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * helper method to trim strings (IE8 does not implement String.prototype.trim)\r\n     */\r\n    Util.trim = function (str) {\r\n        if (typeof str === \"string\") {\r\n            return str.replace(/^\\s+|\\s+$/g, \"\");\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    };\r\n    /**\r\n     * Convert an array of int32 to Base64 (no '==' at the end).\r\n     * MSB first.\r\n     */\r\n    Util.int32ArrayToBase64 = function (array) {\r\n        var toChar = function (v, i) {\r\n            return String.fromCharCode((v >> i) & 0xFF);\r\n        };\r\n        var int32AsString = function (v) {\r\n            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);\r\n        };\r\n        var x = array.map(int32AsString).join(\"\");\r\n        var s = new Buffer(x, \"binary\").toString(\"base64\");\r\n        return s.substr(0, s.indexOf(\"=\"));\r\n    };\r\n    /**\r\n     * generate a random 32bit number (-0x80000000..0x7FFFFFFF).\r\n     */\r\n    Util.random32 = function () {\r\n        return (0x100000000 * Math.random()) | 0;\r\n    };\r\n    /**\r\n     * generate GUID\r\n     */\r\n    Util.newGuid = function () {\r\n        var hexValues = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\r\n        // c.f. rfc4122 (UUID version 4 = xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx)\r\n        var oct = \"\", tmp;\r\n        for (var a = 0; a < 4; a++) {\r\n            tmp = Util.random32();\r\n            oct +=\r\n                hexValues[tmp & 0xF] +\r\n                    hexValues[tmp >> 4 & 0xF] +\r\n                    hexValues[tmp >> 8 & 0xF] +\r\n                    hexValues[tmp >> 12 & 0xF] +\r\n                    hexValues[tmp >> 16 & 0xF] +\r\n                    hexValues[tmp >> 20 & 0xF] +\r\n                    hexValues[tmp >> 24 & 0xF] +\r\n                    hexValues[tmp >> 28 & 0xF];\r\n        }\r\n        // \"Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively\"\r\n        var clockSequenceHi = hexValues[8 + (Math.random() * 4) | 0];\r\n        return oct.substr(0, 8) + \"-\" + oct.substr(9, 4) + \"-4\" + oct.substr(13, 3) + \"-\" + clockSequenceHi + oct.substr(16, 3) + \"-\" + oct.substr(19, 12);\r\n    };\r\n    /**\r\n     * Check if an object is of type Array\r\n     */\r\n    Util.isArray = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Error\r\n     */\r\n    Util.isError = function (obj) {\r\n        return obj instanceof Error;\r\n    };\r\n    /**\r\n     * Check if an object is of type Date\r\n     */\r\n    Util.isDate = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Date]\";\r\n    };\r\n    /**\r\n     * Convert ms to c# time span format\r\n     */\r\n    Util.msToTimeSpan = function (totalms) {\r\n        if (isNaN(totalms) || totalms < 0) {\r\n            totalms = 0;\r\n        }\r\n        var ms = \"\" + totalms % 1000;\r\n        var sec = \"\" + Math.floor(totalms / 1000) % 60;\r\n        var min = \"\" + Math.floor(totalms / (1000 * 60)) % 60;\r\n        var hour = \"\" + Math.floor(totalms / (1000 * 60 * 60)) % 24;\r\n        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));\r\n        ms = ms.length === 1 ? \"00\" + ms : ms.length === 2 ? \"0\" + ms : ms;\r\n        sec = sec.length < 2 ? \"0\" + sec : sec;\r\n        min = min.length < 2 ? \"0\" + min : min;\r\n        hour = hour.length < 2 ? \"0\" + hour : hour;\r\n        var daysText = days > 0 ? days + \".\" : \"\";\r\n        return daysText + hour + \":\" + min + \":\" + sec + \".\" + ms;\r\n    };\r\n    /**\r\n     * Validate that an object is of type { [key: string]: string }\r\n     */\r\n    Util.validateStringMap = function (obj) {\r\n        var map;\r\n        if (typeof obj === \"object\") {\r\n            map = {};\r\n            for (var field in obj) {\r\n                var property = obj[field];\r\n                var propertyType = typeof property;\r\n                if (propertyType !== \"string\") {\r\n                    if (property != null && typeof property.toString === \"function\") {\r\n                        property = property.toString();\r\n                    }\r\n                    else {\r\n                        Logging.info(\"key: \" + field + \", invalid property type: \" + propertyType);\r\n                        continue;\r\n                    }\r\n                }\r\n                map[field] = property.trim(0, Util.MAX_PROPERTY_LENGTH);\r\n            }\r\n        }\r\n        else {\r\n            Logging.info(\"Invalid properties dropped from payload\");\r\n        }\r\n        return map;\r\n    };\r\n    /**\r\n     * Checks if a request url is not on a excluded domain list\r\n     * and if it is safe to add correlation headers (x-ms-request-source-ikey, x-ms-request-target-ikey)\r\n     */\r\n    Util.canIncludeCorrelationHeader = function (client, requestUrl) {\r\n        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;\r\n        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {\r\n            return true;\r\n        }\r\n        for (var i = 0; i < excludedDomains.length; i++) {\r\n            var regex = new RegExp(excludedDomains[i].replace(/\\./g, \"\\.\").replace(/\\*/g, \".*\"));\r\n            if (regex.test(url.parse(requestUrl).hostname)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Util.MAX_PROPERTY_LENGTH = 1024;\r\n    Util.document = typeof document !== \"undefined\" ? document : {};\r\n    return Util;\r\n}());\r\nmodule.exports = Util;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Logging.js":"\"use strict\";\r\nvar Logging = (function () {\r\n    function Logging() {\r\n    }\r\n    Logging.info = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (Logging.enableDebug) {\r\n            console.info(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.warn = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (!Logging.disableWarnings) {\r\n            console.warn(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.enableDebug = false;\r\n    Logging.disableWarnings = false;\r\n    Logging.TAG = \"ApplicationInsights:\";\r\n    return Logging;\r\n}());\r\nmodule.exports = Logging;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/Console.js":"\"use strict\";\r\nvar AutoCollectConsole = (function () {\r\n    function AutoCollectConsole(client) {\r\n        if (!!AutoCollectConsole.INSTANCE) {\r\n            throw new Error(\"Console logging adapter tracking should be configured from the applicationInsights object\");\r\n        }\r\n        this._client = client;\r\n        AutoCollectConsole.INSTANCE = this;\r\n    }\r\n    AutoCollectConsole.prototype.enable = function (isEnabled) {\r\n        // todo: investigate feasibility/utility of this; does it make sense to have a logging adapter in node?\r\n    };\r\n    AutoCollectConsole.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectConsole.prototype.dispose = function () {\r\n        AutoCollectConsole.INSTANCE = null;\r\n    };\r\n    AutoCollectConsole._methodNames = [\"debug\", \"info\", \"log\", \"warn\", \"error\"];\r\n    return AutoCollectConsole;\r\n}());\r\nmodule.exports = AutoCollectConsole;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/Exceptions.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar ContractsModule = require(\"../Library/Contracts\");\r\nvar Util = require(\"../Library/Util\");\r\nvar AutoCollectExceptions = (function () {\r\n    function AutoCollectExceptions(client) {\r\n        if (!!AutoCollectExceptions.INSTANCE) {\r\n            throw new Error(\"Exception tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectExceptions.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectExceptions.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectExceptions.prototype.enable = function (isEnabled) {\r\n        var _this = this;\r\n        if (isEnabled) {\r\n            this._isInitialized = true;\r\n            var self = this;\r\n            if (!this._exceptionListenerHandle) {\r\n                var handle = function (reThrow, error) {\r\n                    var data = AutoCollectExceptions.getExceptionData(error, false);\r\n                    var envelope = _this._client.getEnvelope(data);\r\n                    _this._client.channel.handleCrash(envelope);\r\n                    if (reThrow) {\r\n                        throw error;\r\n                    }\r\n                };\r\n                this._exceptionListenerHandle = handle.bind(this, true);\r\n                this._rejectionListenerHandle = handle.bind(this, false);\r\n                process.on(\"uncaughtException\", this._exceptionListenerHandle);\r\n                process.on(\"unhandledRejection\", this._rejectionListenerHandle);\r\n            }\r\n        }\r\n        else {\r\n            if (this._exceptionListenerHandle) {\r\n                process.removeListener(\"uncaughtException\", this._exceptionListenerHandle);\r\n                process.removeListener(\"unhandledRejection\", this._rejectionListenerHandle);\r\n                this._exceptionListenerHandle = undefined;\r\n                this._rejectionListenerHandle = undefined;\r\n                delete this._exceptionListenerHandle;\r\n                delete this._rejectionListenerHandle;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Track an exception\r\n     * @param error the exception to track\r\n     * @param handledAt where this exception was handled (leave null for unhandled)\r\n     * @param properties additional properties\r\n     * @param measurements metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.\r\n     */\r\n    AutoCollectExceptions.getExceptionData = function (error, isHandled, properties, measurements) {\r\n        var exception = new ContractsModule.Contracts.ExceptionData();\r\n        exception.properties = properties;\r\n        exception.severityLevel = ContractsModule.Contracts.SeverityLevel.Error;\r\n        exception.measurements = measurements;\r\n        exception.exceptions = [];\r\n        var stack = error[\"stack\"];\r\n        var exceptionDetails = new ContractsModule.Contracts.ExceptionDetails();\r\n        exceptionDetails.message = error.message;\r\n        exceptionDetails.typeName = error.name;\r\n        exceptionDetails.parsedStack = this.parseStack(stack);\r\n        exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;\r\n        exception.exceptions.push(exceptionDetails);\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"Microsoft.ApplicationInsights.ExceptionData\";\r\n        data.baseData = exception;\r\n        return data;\r\n    };\r\n    AutoCollectExceptions.parseStack = function (stack) {\r\n        var parsedStack = undefined;\r\n        if (typeof stack === \"string\") {\r\n            var frames = stack.split(\"\\n\");\r\n            parsedStack = [];\r\n            var level = 0;\r\n            var totalSizeInBytes = 0;\r\n            for (var i = 0; i <= frames.length; i++) {\r\n                var frame = frames[i];\r\n                if (_StackFrame.regex.test(frame)) {\r\n                    var parsedFrame = new _StackFrame(frames[i], level++);\r\n                    totalSizeInBytes += parsedFrame.sizeInBytes;\r\n                    parsedStack.push(parsedFrame);\r\n                }\r\n            }\r\n            // DP Constraint - exception parsed stack must be < 32KB\r\n            // remove frames from the middle to meet the threshold\r\n            var exceptionParsedStackThreshold = 32 * 1024;\r\n            if (totalSizeInBytes > exceptionParsedStackThreshold) {\r\n                var left = 0;\r\n                var right = parsedStack.length - 1;\r\n                var size = 0;\r\n                var acceptedLeft = left;\r\n                var acceptedRight = right;\r\n                while (left < right) {\r\n                    // check size\r\n                    var lSize = parsedStack[left].sizeInBytes;\r\n                    var rSize = parsedStack[right].sizeInBytes;\r\n                    size += lSize + rSize;\r\n                    if (size > exceptionParsedStackThreshold) {\r\n                        // remove extra frames from the middle\r\n                        var howMany = acceptedRight - acceptedLeft + 1;\r\n                        parsedStack.splice(acceptedLeft, howMany);\r\n                        break;\r\n                    }\r\n                    // update pointers\r\n                    acceptedLeft = left;\r\n                    acceptedRight = right;\r\n                    left++;\r\n                    right--;\r\n                }\r\n            }\r\n        }\r\n        return parsedStack;\r\n    };\r\n    AutoCollectExceptions.prototype.dispose = function () {\r\n        AutoCollectExceptions.INSTANCE = null;\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectExceptions.INSTANCE = null;\r\n    return AutoCollectExceptions;\r\n}());\r\nvar _StackFrame = (function () {\r\n    function _StackFrame(frame, level) {\r\n        this.sizeInBytes = 0;\r\n        this.level = level;\r\n        this.method = \"<no_method>\";\r\n        this.assembly = Util.trim(frame);\r\n        var matches = frame.match(_StackFrame.regex);\r\n        if (matches && matches.length >= 5) {\r\n            this.method = Util.trim(matches[2]) || this.method;\r\n            this.fileName = Util.trim(matches[4]) || \"<no_filename>\";\r\n            this.line = parseInt(matches[5]) || 0;\r\n        }\r\n        this.sizeInBytes += this.method.length;\r\n        this.sizeInBytes += this.fileName.length;\r\n        this.sizeInBytes += this.assembly.length;\r\n        // todo: these might need to be removed depending on how the back-end settles on their size calculation\r\n        this.sizeInBytes += _StackFrame.baseSize;\r\n        this.sizeInBytes += this.level.toString().length;\r\n        this.sizeInBytes += this.line.toString().length;\r\n    }\r\n    // regex to match stack frames from ie/chrome/ff\r\n    // methodName=$2, fileName=$4, lineNo=$5, column=$6\r\n    _StackFrame.regex = /^([\\s]+at)?(.*?)(\\@|\\s\\(|\\s)([^\\(\\@\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\r\n    _StackFrame.baseSize = 58; //'{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\r\n    return _StackFrame;\r\n}());\r\nmodule.exports = AutoCollectExceptions;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Contracts.js":"// this file is manually constructed and many types and fields here are deprecated.\r\n// Need to switch to use Declarations\\Constracts\\Generated instead\r\n// This will be consistent with JavaScript SDK\r\n\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar Contracts;\r\n(function (Contracts) {\r\n    (function (DataPointType) {\r\n        DataPointType[DataPointType[\"Measurement\"] = 0] = \"Measurement\";\r\n        DataPointType[DataPointType[\"Aggregation\"] = 1] = \"Aggregation\";\r\n    })(Contracts.DataPointType || (Contracts.DataPointType = {}));\r\n    var DataPointType = Contracts.DataPointType;\r\n    (function (SeverityLevel) {\r\n        SeverityLevel[SeverityLevel[\"Verbose\"] = 0] = \"Verbose\";\r\n        SeverityLevel[SeverityLevel[\"Information\"] = 1] = \"Information\";\r\n        SeverityLevel[SeverityLevel[\"Warning\"] = 2] = \"Warning\";\r\n        SeverityLevel[SeverityLevel[\"Error\"] = 3] = \"Error\";\r\n        SeverityLevel[SeverityLevel[\"Critical\"] = 4] = \"Critical\";\r\n    })(Contracts.SeverityLevel || (Contracts.SeverityLevel = {}));\r\n    var SeverityLevel = Contracts.SeverityLevel;\r\n    var ContextTagKeys = (function () {\r\n        function ContextTagKeys() {\r\n            this.applicationVersion = \"ai.application.ver\";\r\n            this.deviceId = \"ai.device.id\";\r\n            this.deviceLocale = \"ai.device.locale\";\r\n            this.deviceModel = \"ai.device.model\";\r\n            this.deviceOEMName = \"ai.device.oemName\";\r\n            this.deviceOSVersion = \"ai.device.osVersion\";\r\n            this.deviceType = \"ai.device.type\";\r\n            this.locationIp = \"ai.location.ip\";\r\n            this.operationId = \"ai.operation.id\";\r\n            this.operationName = \"ai.operation.name\";\r\n            this.operationParentId = \"ai.operation.parentId\";\r\n            this.operationSyntheticSource = \"ai.operation.syntheticSource\";\r\n            this.operationCorrelationVector = \"ai.operation.correlationVector\";\r\n            this.sessionId = \"ai.session.id\";\r\n            this.sessionIsFirst = \"ai.session.isFirst\";\r\n            this.userAccountId = \"ai.user.accountId\";\r\n            this.userAgent = \"ai.user.userAgent\";\r\n            this.userId = \"ai.user.id\";\r\n            this.userAuthUserId = \"ai.user.authUserId\";\r\n            this.cloudRole = \"ai.cloud.role\";\r\n            this.cloudRoleInstance = \"ai.cloud.roleInstance\";\r\n            this.internalSdkVersion = \"ai.internal.sdkVersion\";\r\n            this.internalAgentVersion = \"ai.internal.agentVersion\";\r\n            this.internalNodeName = \"ai.internal.nodeName\";\r\n        }\r\n        return ContextTagKeys;\r\n    }());\r\n    Contracts.ContextTagKeys = ContextTagKeys;\r\n    var Domain = (function () {\r\n        function Domain() {\r\n        }\r\n        return Domain;\r\n    }());\r\n    Contracts.Domain = Domain;\r\n    var Data = (function () {\r\n        function Data() {\r\n        }\r\n        return Data;\r\n    }());\r\n    Contracts.Data = Data;\r\n    var Envelope = (function () {\r\n        function Envelope() {\r\n            this.ver = 1;\r\n            // the 'name' property must be initialized before 'tags' and/or 'data'.\r\n            this.name = \"\";\r\n            // the 'time' property must be initialized before 'tags' and/or 'data'.\r\n            this.time = \"\";\r\n            this.sampleRate = 100.0;\r\n            this.tags = {};\r\n        }\r\n        return Envelope;\r\n    }());\r\n    Contracts.Envelope = Envelope;\r\n    var EventData = (function (_super) {\r\n        __extends(EventData, _super);\r\n        function EventData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.properties = {};\r\n            this.measurements = {};\r\n            _super.call(this);\r\n        }\r\n        return EventData;\r\n    }(Contracts.Domain));\r\n    Contracts.EventData = EventData;\r\n    var MessageData = (function (_super) {\r\n        __extends(MessageData, _super);\r\n        function MessageData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.properties = {};\r\n            _super.call(this);\r\n        }\r\n        return MessageData;\r\n    }(Contracts.Domain));\r\n    Contracts.MessageData = MessageData;\r\n    var ExceptionData = (function (_super) {\r\n        __extends(ExceptionData, _super);\r\n        function ExceptionData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.exceptions = [];\r\n            this.properties = {};\r\n            this.measurements = {};\r\n        }\r\n        return ExceptionData;\r\n    }(Contracts.Domain));\r\n    Contracts.ExceptionData = ExceptionData;\r\n    var StackFrame = (function () {\r\n        function StackFrame() {\r\n        }\r\n        return StackFrame;\r\n    }());\r\n    Contracts.StackFrame = StackFrame;\r\n    var ExceptionDetails = (function () {\r\n        function ExceptionDetails() {\r\n            this.hasFullStack = true;\r\n            this.parsedStack = [];\r\n        }\r\n        return ExceptionDetails;\r\n    }());\r\n    Contracts.ExceptionDetails = ExceptionDetails;\r\n    var DataPoint = (function () {\r\n        function DataPoint() {\r\n            this.kind = Contracts.DataPointType.Measurement;\r\n        }\r\n        return DataPoint;\r\n    }());\r\n    Contracts.DataPoint = DataPoint;\r\n    var MetricData = (function (_super) {\r\n        __extends(MetricData, _super);\r\n        function MetricData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.metrics = [];\r\n            this.properties = {};\r\n            _super.call(this);\r\n        }\r\n        return MetricData;\r\n    }(Contracts.Domain));\r\n    Contracts.MetricData = MetricData;\r\n    var PageViewData = (function (_super) {\r\n        __extends(PageViewData, _super);\r\n        function PageViewData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.properties = {};\r\n            this.measurements = {};\r\n            _super.call(this);\r\n        }\r\n        return PageViewData;\r\n    }(Contracts.EventData));\r\n    Contracts.PageViewData = PageViewData;\r\n    var PageViewPerfData = (function (_super) {\r\n        __extends(PageViewPerfData, _super);\r\n        function PageViewPerfData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.properties = {};\r\n            this.measurements = {};\r\n        }\r\n        return PageViewPerfData;\r\n    }(Contracts.PageViewData));\r\n    Contracts.PageViewPerfData = PageViewPerfData;\r\n    var RemoteDependencyDataConstants = (function () {\r\n        function RemoteDependencyDataConstants() {\r\n        }\r\n        RemoteDependencyDataConstants.TYPE_HTTP = \"Http\";\r\n        return RemoteDependencyDataConstants;\r\n    }());\r\n    Contracts.RemoteDependencyDataConstants = RemoteDependencyDataConstants;\r\n    var RemoteDependencyData = (function (_super) {\r\n        __extends(RemoteDependencyData, _super);\r\n        function RemoteDependencyData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.success = true;\r\n            this.properties = {};\r\n            this.measurements = {};\r\n        }\r\n        return RemoteDependencyData;\r\n    }(Contracts.Domain));\r\n    Contracts.RemoteDependencyData = RemoteDependencyData;\r\n    var AjaxCallData = (function (_super) {\r\n        __extends(AjaxCallData, _super);\r\n        function AjaxCallData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.properties = {};\r\n            this.measurements = {};\r\n            _super.call(this);\r\n        }\r\n        return AjaxCallData;\r\n    }(Contracts.PageViewData));\r\n    Contracts.AjaxCallData = AjaxCallData;\r\n    var RequestData = (function (_super) {\r\n        __extends(RequestData, _super);\r\n        function RequestData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.properties = {};\r\n            this.measurements = {};\r\n        }\r\n        return RequestData;\r\n    }(Contracts.Domain));\r\n    Contracts.RequestData = RequestData;\r\n    var PerformanceCounterData = (function (_super) {\r\n        __extends(PerformanceCounterData, _super);\r\n        function PerformanceCounterData() {\r\n            _super.call(this);\r\n            this.ver = 2;\r\n            this.kind = DataPointType.Aggregation;\r\n            this.properties = {};\r\n            _super.call(this);\r\n        }\r\n        return PerformanceCounterData;\r\n    }(Contracts.Domain));\r\n    Contracts.PerformanceCounterData = PerformanceCounterData;\r\n})(Contracts = exports.Contracts || (exports.Contracts = {}));\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/Performance.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar http = require(\"http\");\r\nvar os = require(\"os\");\r\nvar ContractsModule = require(\"../Library/Contracts\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar PerfCounterType;\r\n(function (PerfCounterType) {\r\n    PerfCounterType[PerfCounterType[\"ProcessorTime\"] = 0] = \"ProcessorTime\";\r\n    PerfCounterType[PerfCounterType[\"AvailableMemory\"] = 1] = \"AvailableMemory\";\r\n    PerfCounterType[PerfCounterType[\"RequestsPerSec\"] = 2] = \"RequestsPerSec\";\r\n    PerfCounterType[PerfCounterType[\"PrivateBytes\"] = 3] = \"PrivateBytes\";\r\n    PerfCounterType[PerfCounterType[\"RequestExecutionTime\"] = 4] = \"RequestExecutionTime\";\r\n    PerfCounterType[PerfCounterType[\"PercentProcessorTime\"] = 5] = \"PercentProcessorTime\";\r\n})(PerfCounterType || (PerfCounterType = {}));\r\nvar AutoCollectPerformance = (function () {\r\n    function AutoCollectPerformance(client) {\r\n        if (!!AutoCollectPerformance.INSTANCE) {\r\n            throw new Error(\"Performance tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectPerformance.INSTANCE = this;\r\n        this._isInitialized = false;\r\n        this._client = client;\r\n    }\r\n    AutoCollectPerformance.prototype.enable = function (isEnabled) {\r\n        var _this = this;\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._initialize();\r\n        }\r\n        if (isEnabled) {\r\n            if (!this._handle) {\r\n                this._lastCpus = os.cpus();\r\n                this._lastRequests = {\r\n                    totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n                    totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n                    time: +new Date\r\n                };\r\n                this._handle = setInterval(function () { return _this.trackPerformance(); }, 10000);\r\n            }\r\n        }\r\n        else {\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = undefined;\r\n            }\r\n        }\r\n    };\r\n    AutoCollectPerformance.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectPerformance.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var originalServer = http.createServer;\r\n        http.createServer = function (onRequest) {\r\n            return originalServer(function (request, response) {\r\n                if (_this._isEnabled) {\r\n                    AutoCollectPerformance.countRequest(request, response);\r\n                }\r\n                if (typeof onRequest === \"function\") {\r\n                    onRequest(request, response);\r\n                }\r\n            });\r\n        };\r\n    };\r\n    AutoCollectPerformance.countRequest = function (request, response) {\r\n        var _this = this;\r\n        var start = +new Date;\r\n        if (!request || !response) {\r\n            Logging.warn(\"AutoCollectPerformance.countRequest was called with invalid parameters: \", !!request, !!response);\r\n            return;\r\n        }\r\n        // response listeners\r\n        if (typeof response.once === \"function\") {\r\n            response.once(\"finish\", function () {\r\n                var end = +new Date;\r\n                _this._lastRequestExecutionTime = end - start;\r\n                AutoCollectPerformance._totalRequestCount++;\r\n                if (response.statusCode >= 400) {\r\n                    AutoCollectPerformance._totalFailedRequestCount++;\r\n                }\r\n            });\r\n        }\r\n    };\r\n    AutoCollectPerformance.prototype.trackPerformance = function () {\r\n        this._trackCpu();\r\n        this._trackMemory();\r\n        this._trackNetwork();\r\n    };\r\n    // this is necessary to accommodate some point-in-time UI quirks\r\n    AutoCollectPerformance.prototype._trackLegacyPerformance = function (counterType, value) {\r\n        var perfmetric = new ContractsModule.Contracts.PerformanceCounterData();\r\n        // semantic descriptions of these can be found here: https://support.microsoft.com/en-us/kb/815159/\r\n        switch (counterType) {\r\n            case PerfCounterType.ProcessorTime:\r\n                perfmetric.categoryName = \"Process\";\r\n                perfmetric.counterName = \"% Processor Time\";\r\n                break;\r\n            case PerfCounterType.AvailableMemory:\r\n                perfmetric.categoryName = \"Memory\";\r\n                perfmetric.counterName = \"Available Bytes\";\r\n                break;\r\n            case PerfCounterType.RequestsPerSec:\r\n                perfmetric.categoryName = \"ASP.NET Applications\";\r\n                perfmetric.counterName = \"Requests/Sec\";\r\n                break;\r\n            case PerfCounterType.PrivateBytes:\r\n                perfmetric.categoryName = \"Process\";\r\n                perfmetric.counterName = \"Private Bytes\";\r\n                break;\r\n            case PerfCounterType.RequestExecutionTime:\r\n                perfmetric.categoryName = \"ASP.NET Applications\";\r\n                perfmetric.counterName = \"Request Execution Time\";\r\n                break;\r\n            case PerfCounterType.PercentProcessorTime:\r\n                perfmetric.categoryName = \"Processor\";\r\n                perfmetric.counterName = \"% Processor Time\";\r\n                break;\r\n        }\r\n        perfmetric.count = 1;\r\n        perfmetric.kind = ContractsModule.Contracts.DataPointType.Aggregation;\r\n        perfmetric.max = value;\r\n        perfmetric.min = value;\r\n        perfmetric.stdDev = 0;\r\n        perfmetric.value = value;\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"Microsoft.ApplicationInsights.PerformanceCounterData\";\r\n        data.baseData = perfmetric;\r\n        this._client.track(data);\r\n    };\r\n    AutoCollectPerformance.prototype._trackCpu = function () {\r\n        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary\r\n        // to find the delta since the last measurement\r\n        var cpus = os.cpus();\r\n        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {\r\n            var totalUser = 0;\r\n            var totalSys = 0;\r\n            var totalNice = 0;\r\n            var totalIdle = 0;\r\n            var totalIrq = 0;\r\n            for (var i = 0; !!cpus && i < cpus.length; i++) {\r\n                var cpu = cpus[i];\r\n                var lastCpu = this._lastCpus[i];\r\n                var name = \"% cpu(\" + i + \") \";\r\n                var model = cpu.model;\r\n                var speed = cpu.speed;\r\n                var times = cpu.times;\r\n                var lastTimes = lastCpu.times;\r\n                // user cpu time (or) % CPU time spent in user space\r\n                var user = (times.user - lastTimes.user) || 0;\r\n                totalUser += user;\r\n                // system cpu time (or) % CPU time spent in kernel space\r\n                var sys = (times.sys - lastTimes.sys) || 0;\r\n                totalSys += sys;\r\n                // user nice cpu time (or) % CPU time spent on low priority processes\r\n                var nice = (times.nice - lastTimes.nice) || 0;\r\n                totalNice += nice;\r\n                // idle cpu time (or) % CPU time spent idle\r\n                var idle = (times.idle - lastTimes.idle) || 0;\r\n                totalIdle += idle;\r\n                // irq (or) % CPU time spent servicing/handling hardware interrupts\r\n                var irq = (times.irq - lastTimes.irq) || 0;\r\n                totalIrq += irq;\r\n                var total = (user + sys + nice + idle + irq) || 1; // don\"t let this be 0 since it is a divisor\r\n                this._client.trackMetric(name + \"user\", user / total);\r\n            }\r\n            var combinedName = \"% total cpu \";\r\n            var combinedTotal = (totalUser + totalSys + totalNice + totalIdle + totalIrq) || 1;\r\n            this._client.trackMetric(combinedName + \"user\", totalUser / combinedTotal);\r\n            this._client.trackMetric(combinedName + \"sys\", totalSys / combinedTotal);\r\n            this._client.trackMetric(combinedName + \"nice\", totalNice / combinedTotal);\r\n            this._client.trackMetric(combinedName + \"idle\", totalIdle / combinedTotal);\r\n            this._client.trackMetric(combinedName + \"irq\", totalIrq / combinedTotal);\r\n            // todo: remove this legacy counter once the UI updates (~june 2015)\r\n            this._trackLegacyPerformance(PerfCounterType.ProcessorTime, totalUser / combinedTotal);\r\n            this._trackLegacyPerformance(PerfCounterType.PercentProcessorTime, (combinedTotal - totalIdle) / combinedTotal);\r\n        }\r\n        this._lastCpus = cpus;\r\n    };\r\n    AutoCollectPerformance.prototype._trackMemory = function () {\r\n        var totalMem = os.totalmem();\r\n        var freeMem = os.freemem();\r\n        var usedMem = totalMem - freeMem;\r\n        var percentUsedMem = usedMem / (totalMem || 1);\r\n        var percentAvailableMem = freeMem / (totalMem || 1);\r\n        this._client.trackMetric(\"Memory Used\", usedMem);\r\n        this._client.trackMetric(\"Memory Free\", freeMem);\r\n        this._client.trackMetric(\"Memory Total\", totalMem);\r\n        this._client.trackMetric(\"% Memory Used\", percentUsedMem);\r\n        this._client.trackMetric(\"% Memory Free\", percentAvailableMem);\r\n        // todo: remove this legacy counter once the UI updates (~june 2015)\r\n        this._trackLegacyPerformance(PerfCounterType.AvailableMemory, freeMem);\r\n        this._trackLegacyPerformance(PerfCounterType.PrivateBytes, usedMem);\r\n    };\r\n    AutoCollectPerformance.prototype._trackNetwork = function () {\r\n        // track total request counters\r\n        var lastRequests = this._lastRequests;\r\n        var requests = {\r\n            totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n            totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n            time: +new Date\r\n        };\r\n        var intervalRequests = (requests.totalRequestCount - lastRequests.totalRequestCount) || 0;\r\n        var intervalFailedRequests = (requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount) || 0;\r\n        var elapsedMs = requests.time - lastRequests.time;\r\n        var elapsedSeconds = elapsedMs / 1000;\r\n        if (elapsedMs > 0) {\r\n            var requestsPerSec = intervalRequests / elapsedSeconds;\r\n            var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;\r\n            this._client.trackMetric(\"Total Requests\", requests.totalRequestCount);\r\n            this._client.trackMetric(\"Total Failed Requests\", requests.totalFailedRequestCount);\r\n            this._client.trackMetric(\"Requests per Second\", requestsPerSec);\r\n            this._client.trackMetric(\"Failed Requests per Second\", failedRequestsPerSec);\r\n            this._client.trackMetric(\"Last Request Execution Time\", AutoCollectPerformance._lastRequestExecutionTime);\r\n            // todo: remove this legacy counter once the UI updates (~june 2015)\r\n            this._trackLegacyPerformance(PerfCounterType.RequestsPerSec, requestsPerSec);\r\n            this._trackLegacyPerformance(PerfCounterType.RequestExecutionTime, AutoCollectPerformance._lastRequestExecutionTime);\r\n        }\r\n        this._lastRequests = requests;\r\n    };\r\n    AutoCollectPerformance.prototype.dispose = function () {\r\n        AutoCollectPerformance.INSTANCE = null;\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectPerformance._totalRequestCount = 0;\r\n    AutoCollectPerformance._totalFailedRequestCount = 0;\r\n    AutoCollectPerformance._lastRequestExecutionTime = 0;\r\n    return AutoCollectPerformance;\r\n}());\r\nmodule.exports = AutoCollectPerformance;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/ClientRequests.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar ClientRequestParser = require(\"./ClientRequestParser\");\r\nvar AutoCollectClientRequests = (function () {\r\n    function AutoCollectClientRequests(client) {\r\n        if (!!AutoCollectClientRequests.INSTANCE) {\r\n            throw new Error(\"Client request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectClientRequests.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectClientRequests.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._initialize();\r\n        }\r\n    };\r\n    AutoCollectClientRequests.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectClientRequests.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var originalRequest = http.request;\r\n        http.request = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = originalRequest.call.apply(originalRequest, [http, options].concat(requestArgs));\r\n            if (request && options && !options[AutoCollectClientRequests.disableCollectionRequestOption]) {\r\n                AutoCollectClientRequests.trackRequest(_this._client, options, request);\r\n            }\r\n            return request;\r\n        };\r\n        // On node >= v0.11.12, https.request just calls http.request (with additional options).\r\n        // But on older versions, https.request needs to be patched also.\r\n        // The regex matches versions < 0.11.12 (avoiding a semver package dependency).\r\n        if (/^0\\.([0-9]\\.)|(10\\.)|(11\\.([0-9]|10|11)$)/.test(process.versions.node)) {\r\n            var originalHttpsRequest_1 = https.request;\r\n            https.request = function (options) {\r\n                var requestArgs = [];\r\n                for (var _i = 1; _i < arguments.length; _i++) {\r\n                    requestArgs[_i - 1] = arguments[_i];\r\n                }\r\n                var request = originalHttpsRequest_1.call.apply(originalHttpsRequest_1, [https, options].concat(requestArgs));\r\n                if (request && options && !options[AutoCollectClientRequests.disableCollectionRequestOption]) {\r\n                    AutoCollectClientRequests.trackRequest(_this._client, options, request);\r\n                }\r\n                return request;\r\n            };\r\n        }\r\n    };\r\n    /**\r\n     * Tracks an outgoing request. Because it may set headers this method must be called before\r\n     * writing content to or ending the request.\r\n     */\r\n    AutoCollectClientRequests.trackRequest = function (client, requestOptions, request, properties) {\r\n        if (!requestOptions || !request || !client) {\r\n            Logging.info(\"AutoCollectClientRequests.trackRequest was called with invalid parameters: \", !requestOptions, !request, !client);\r\n            return;\r\n        }\r\n        var requestParser = new ClientRequestParser(requestOptions, request);\r\n        // Add the source ikey hash to the request headers, if a value was not already provided.\r\n        // The getHeader/setHeader methods aren't available on very old Node versions, and\r\n        // are not included in the v0.10 type declarations currently used. So check if the\r\n        // methods exist before invoking them.\r\n        if (client.config && client.config.instrumentationKeyHash &&\r\n            Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) &&\r\n            request['getHeader'] && request['setHeader'] &&\r\n            !request['getHeader'](RequestResponseHeaders.sourceInstrumentationKeyHeader)) {\r\n            request['setHeader'](RequestResponseHeaders.sourceInstrumentationKeyHeader, client.config.instrumentationKeyHash);\r\n        }\r\n        // Collect dependency telemetry about the request when it finishes.\r\n        if (request.on) {\r\n            request.on('response', function (response) {\r\n                requestParser.onResponse(response, properties);\r\n                var context = { \"http.RequestOptions\": requestOptions, \"http.ClientRequest\": request, \"http.ClientResponse\": response };\r\n                client.track(requestParser.getDependencyData(), null, context);\r\n            });\r\n            request.on('error', function (e) {\r\n                requestParser.onError(e, properties);\r\n                var context = { \"http.RequestOptions\": requestOptions, \"http.ClientRequest\": request, \"Error\": e };\r\n                client.track(requestParser.getDependencyData(), null, context);\r\n            });\r\n        }\r\n    };\r\n    AutoCollectClientRequests.prototype.dispose = function () {\r\n        AutoCollectClientRequests.INSTANCE = null;\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectClientRequests.disableCollectionRequestOption = 'disableAppInsightsAutoCollection';\r\n    return AutoCollectClientRequests;\r\n}());\r\nmodule.exports = AutoCollectClientRequests;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/RequestResponseHeaders.js":"\"use strict\";\r\nmodule.exports = {\r\n    /**\r\n     * Source instrumentation header that is added by an application while making http\r\n     * requests and retrieved by the other application when processing incoming requests.\r\n     */\r\n    sourceInstrumentationKeyHeader: \"x-ms-request-source-ikey\",\r\n    /**\r\n     * Target instrumentation header that is added to the response and retrieved by the\r\n     * calling application when processing incoming responses.\r\n     */\r\n    targetInstrumentationKeyHeader: \"x-ms-request-target-ikey\",\r\n    /**\r\n     * Header containing the id of the immidiate caller\r\n     */\r\n    parentIdHeader: \"x-ms-request-id\",\r\n    /**\r\n     * Header containing the correlation id that kept the same for every telemetry item\r\n     * accross transactions\r\n     */\r\n    rootIdHeader: \"x-ms-request-root-id\"\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/ClientRequestParser.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar url = require(\"url\");\r\nvar ContractsModule = require(\"../Library/Contracts\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar RequestParser = require(\"./RequestParser\");\r\n/**\r\n * Helper class to read data from the requst/response objects and convert them into the telemetry contract\r\n */\r\nvar ClientRequestParser = (function (_super) {\r\n    __extends(ClientRequestParser, _super);\r\n    function ClientRequestParser(requestOptions, request) {\r\n        _super.call(this);\r\n        if (request && request.method && requestOptions) {\r\n            // The ClientRequest.method property isn't documented, but is always there.\r\n            this.method = request.method;\r\n            this.url = ClientRequestParser._getUrlFromRequestOptions(requestOptions, request);\r\n            this.startTime = +new Date();\r\n        }\r\n    }\r\n    /**\r\n     * Called when the ClientRequest emits an error event.\r\n     */\r\n    ClientRequestParser.prototype.onError = function (error, properties) {\r\n        this._setStatus(undefined, error, properties);\r\n    };\r\n    /**\r\n     * Called when the ClientRequest emits a response event.\r\n     */\r\n    ClientRequestParser.prototype.onResponse = function (response, properties) {\r\n        this._setStatus(response.statusCode, undefined, properties);\r\n        this.targetIKeyHash =\r\n            response.headers && response.headers[RequestResponseHeaders.targetInstrumentationKeyHeader];\r\n    };\r\n    /**\r\n     * Gets a dependency data contract object for a completed ClientRequest.\r\n     */\r\n    ClientRequestParser.prototype.getDependencyData = function () {\r\n        var urlObject = url.parse(this.url);\r\n        urlObject.search = undefined;\r\n        urlObject.hash = undefined;\r\n        var dependencyName = this.method.toUpperCase() + \" \" + urlObject.pathname;\r\n        var remoteDependency = new ContractsModule.Contracts.RemoteDependencyData();\r\n        remoteDependency.type = ContractsModule.Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n        if (this.targetIKeyHash) {\r\n            remoteDependency.type = \"ApplicationInsights\";\r\n            remoteDependency.target = urlObject.hostname + \" | \" + this.targetIKeyHash;\r\n        }\r\n        else {\r\n            remoteDependency.type = ContractsModule.Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n            remoteDependency.target = urlObject.hostname;\r\n        }\r\n        remoteDependency.name = dependencyName;\r\n        remoteDependency.data = this.url;\r\n        remoteDependency.duration = Util.msToTimeSpan(this.duration);\r\n        remoteDependency.success = this._isSuccess();\r\n        remoteDependency.resultCode = this.statusCode ? this.statusCode.toString() : null;\r\n        remoteDependency.properties = this.properties || {};\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"Microsoft.ApplicationInsights.RemoteDependencyData\";\r\n        data.baseData = remoteDependency;\r\n        return data;\r\n    };\r\n    /**\r\n     * Builds a URL from request options, using the same logic as http.request(). This is\r\n     * necessary because a ClientRequest object does not expose a url property.\r\n     */\r\n    ClientRequestParser._getUrlFromRequestOptions = function (options, request) {\r\n        if (typeof options === 'string') {\r\n            options = url.parse(options);\r\n        }\r\n        else {\r\n            // Avoid modifying the original options object.\r\n            var originalOptions_1 = options;\r\n            options = {};\r\n            if (originalOptions_1) {\r\n                Object.keys(originalOptions_1).forEach(function (key) {\r\n                    options[key] = originalOptions_1[key];\r\n                });\r\n            }\r\n        }\r\n        // Oddly, url.format ignores path and only uses pathname and search,\r\n        // so create them from the path, if path was specified\r\n        if (options.path) {\r\n            var parsedQuery = url.parse(options.path);\r\n            options.pathname = parsedQuery.pathname;\r\n            options.search = parsedQuery.search;\r\n        }\r\n        // Simiarly, url.format ignores hostname and port if host is specified,\r\n        // even if host doesn't have the port, but http.request does not work\r\n        // this way. It will use the port if one is not specified in host,\r\n        // effectively treating host as hostname, but will use the port specified\r\n        // in host if it exists.\r\n        if (options.host && options.port) {\r\n            // Force a protocol so it will parse the host as the host, not path.\r\n            // It is discarded and not used, so it doesn't matter if it doesn't match\r\n            var parsedHost = url.parse(\"http://\" + options.host);\r\n            if (!parsedHost.port && options.port) {\r\n                options.hostname = options.host;\r\n                delete options.host;\r\n            }\r\n        }\r\n        // Mix in default values used by http.request and others\r\n        options.protocol = options.protocol || request.agent.protocol;\r\n        options.hostname = options.hostname || 'localhost';\r\n        return url.format(options);\r\n    };\r\n    return ClientRequestParser;\r\n}(RequestParser));\r\nmodule.exports = ClientRequestParser;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/RequestParser.js":"\"use strict\";\r\n/**\r\n * Base class for helpers that read data from HTTP requst/response objects and convert them\r\n * into the telemetry contract objects.\r\n */\r\nvar RequestParser = (function () {\r\n    function RequestParser() {\r\n    }\r\n    /**\r\n     * Gets a url parsed out from request options\r\n     */\r\n    RequestParser.prototype.getUrl = function () {\r\n        return this.url;\r\n    };\r\n    RequestParser.prototype.RequestParser = function () {\r\n        this.startTime = +new Date();\r\n    };\r\n    RequestParser.prototype._setStatus = function (status, error, properties) {\r\n        var endTime = +new Date();\r\n        this.duration = endTime - this.startTime;\r\n        this.statusCode = status;\r\n        if (error) {\r\n            if (!properties) {\r\n                properties = {};\r\n            }\r\n            if (typeof error === \"string\") {\r\n                properties[\"error\"] = error;\r\n            }\r\n            else if (error instanceof Error) {\r\n                properties[\"error\"] = error.message;\r\n            }\r\n            else if (typeof error === \"object\") {\r\n                for (var key in error) {\r\n                    properties[key] = error[key] && error[key].toString && error[key].toString();\r\n                }\r\n            }\r\n        }\r\n        this.properties = properties;\r\n    };\r\n    RequestParser.prototype._isSuccess = function () {\r\n        return (0 < this.statusCode) && (this.statusCode < 400);\r\n    };\r\n    return RequestParser;\r\n}());\r\nmodule.exports = RequestParser;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/ServerRequests.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar ServerRequestParser = require(\"./ServerRequestParser\");\r\nvar CorrelationContextManager_1 = require(\"./CorrelationContextManager\");\r\nvar AutoCollectServerRequests = (function () {\r\n    function AutoCollectServerRequests(client) {\r\n        if (!!AutoCollectServerRequests.INSTANCE) {\r\n            throw new Error(\"Server request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectServerRequests.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectServerRequests.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        // Autocorrelation requires automatic monitoring of incoming server requests\r\n        // Disabling autocollection but enabling autocorrelation will still enable\r\n        // request monitoring but will not produce request events\r\n        if ((this._isAutoCorrelating || this._isEnabled) && !this._isInitialized) {\r\n            this.useAutoCorrelation(this._isAutoCorrelating);\r\n            this._initialize();\r\n        }\r\n    };\r\n    AutoCollectServerRequests.prototype.useAutoCorrelation = function (isEnabled) {\r\n        if (isEnabled && !this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.enable();\r\n        }\r\n        else if (!isEnabled && this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.disable();\r\n        }\r\n        this._isAutoCorrelating = isEnabled;\r\n    };\r\n    AutoCollectServerRequests.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectServerRequests.prototype.isAutoCorrelating = function () {\r\n        return this._isAutoCorrelating;\r\n    };\r\n    AutoCollectServerRequests.prototype._generateCorrelationContext = function (requestParser) {\r\n        if (!this._isAutoCorrelating) {\r\n            return;\r\n        }\r\n        return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getOperationId(this._client.context.tags));\r\n    };\r\n    AutoCollectServerRequests.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var originalHttpServer = http.createServer;\r\n        http.createServer = function (onRequest) {\r\n            // todo: get a pointer to the server so the IP address can be read from server.address\r\n            return originalHttpServer(function (request, response) {\r\n                // Set up correlation context\r\n                var requestParser = new ServerRequestParser(request);\r\n                var correlationContext = _this._generateCorrelationContext(requestParser);\r\n                CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {\r\n                    if (_this._isEnabled) {\r\n                        // Auto collect request\r\n                        AutoCollectServerRequests.trackRequest(_this._client, request, response, null, requestParser);\r\n                    }\r\n                    if (typeof onRequest === \"function\") {\r\n                        onRequest(request, response);\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        var originalHttpsServer = https.createServer;\r\n        https.createServer = function (options, onRequest) {\r\n            return originalHttpsServer(options, function (request, response) {\r\n                // Set up correlation context\r\n                var requestParser = new ServerRequestParser(request);\r\n                var correlationContext = _this._generateCorrelationContext(requestParser);\r\n                CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {\r\n                    if (_this._isEnabled) {\r\n                        AutoCollectServerRequests.trackRequest(_this._client, request, response, null, requestParser);\r\n                    }\r\n                    if (typeof onRequest === \"function\") {\r\n                        onRequest(request, response);\r\n                    }\r\n                });\r\n            });\r\n        };\r\n    };\r\n    /**\r\n     * Tracks a request synchronously (doesn't wait for response 'finish' event)\r\n     */\r\n    AutoCollectServerRequests.trackRequestSync = function (client, request, response, ellapsedMilliseconds, properties, error) {\r\n        if (!request || !response || !client) {\r\n            Logging.info(\"AutoCollectServerRequests.trackRequestSync was called with invalid parameters: \", !request, !response, !client);\r\n            return;\r\n        }\r\n        AutoCollectServerRequests.addResponseIKeyHeader(client, response);\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = new ServerRequestParser(request, (correlationContext && correlationContext.operation.parentId) || Util.newGuid());\r\n        // Overwrite correlation context with request parser results\r\n        if (correlationContext) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;\r\n        }\r\n        AutoCollectServerRequests.endRequest(client, requestParser, request, response, ellapsedMilliseconds, properties, error);\r\n    };\r\n    /**\r\n     * Tracks a request by listening to the response 'finish' event\r\n     */\r\n    AutoCollectServerRequests.trackRequest = function (client, request, response, properties, _requestParser) {\r\n        if (!request || !response || !client) {\r\n            Logging.info(\"AutoCollectServerRequests.trackRequest was called with invalid parameters: \", !request, !response, !client);\r\n            return;\r\n        }\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = _requestParser || new ServerRequestParser(request, correlationContext && correlationContext.operation.parentId || Util.newGuid());\r\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {\r\n            AutoCollectServerRequests.addResponseIKeyHeader(client, response);\r\n        }\r\n        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)\r\n        if (correlationContext && !_requestParser) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;\r\n        }\r\n        // response listeners\r\n        if (response.once) {\r\n            response.once(\"finish\", function () {\r\n                AutoCollectServerRequests.endRequest(client, requestParser, request, response, null, properties, null);\r\n            });\r\n        }\r\n        // track a failed request if an error is emitted\r\n        if (request.on) {\r\n            request.on(\"error\", function (error) {\r\n                AutoCollectServerRequests.endRequest(client, requestParser, request, response, null, properties, error);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Add the target ikey hash to the response headers, if not already provided.\r\n     */\r\n    AutoCollectServerRequests.addResponseIKeyHeader = function (client, response) {\r\n        if (client.config && client.config.instrumentationKeyHash &&\r\n            response.getHeader && response.setHeader &&\r\n            !response.getHeader(RequestResponseHeaders.targetInstrumentationKeyHeader) &&\r\n            !response.headersSent) {\r\n            response.setHeader(RequestResponseHeaders.targetInstrumentationKeyHeader, client.config.instrumentationKeyHash);\r\n        }\r\n    };\r\n    AutoCollectServerRequests.endRequest = function (client, requestParser, request, response, ellapsedMilliseconds, properties, error) {\r\n        if (error) {\r\n            requestParser.onError(error, properties, ellapsedMilliseconds);\r\n        }\r\n        else {\r\n            requestParser.onResponse(response, properties, ellapsedMilliseconds);\r\n        }\r\n        var context = { \"http.ServerRequest\": request, \"http.ServerResponse\": response };\r\n        var data = requestParser.getRequestData();\r\n        var tags = requestParser.getRequestTags(client.context.tags);\r\n        client.track(data, tags, context);\r\n    };\r\n    AutoCollectServerRequests.prototype.dispose = function () {\r\n        AutoCollectServerRequests.INSTANCE = null;\r\n        this._isInitialized = false;\r\n    };\r\n    return AutoCollectServerRequests;\r\n}());\r\nmodule.exports = AutoCollectServerRequests;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/AutoCollection/ServerRequestParser.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar url = require(\"url\");\r\nvar ContractsModule = require(\"../Library/Contracts\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar RequestParser = require(\"./RequestParser\");\r\n/**\r\n * Helper class to read data from the requst/response objects and convert them into the telemetry contract\r\n */\r\nvar ServerRequestParser = (function (_super) {\r\n    __extends(ServerRequestParser, _super);\r\n    function ServerRequestParser(request, requestId) {\r\n        _super.call(this);\r\n        if (request) {\r\n            this.requestId = requestId || Util.newGuid();\r\n            this.method = request.method;\r\n            this.url = this._getAbsoluteUrl(request);\r\n            this.startTime = +new Date();\r\n            this.rawHeaders = request.headers || request.rawHeaders;\r\n            this.socketRemoteAddress = request.socket && request.socket.remoteAddress;\r\n            this.userAgent = request.headers && request.headers[\"user-agent\"];\r\n            this.sourceIKeyHash =\r\n                request.headers && request.headers[RequestResponseHeaders.sourceInstrumentationKeyHeader];\r\n            this.parentId =\r\n                request.headers && request.headers[RequestResponseHeaders.parentIdHeader];\r\n            this.operationId =\r\n                request.headers && request.headers[RequestResponseHeaders.rootIdHeader];\r\n            if (request.connection) {\r\n                this.connectionRemoteAddress = request.connection.remoteAddress;\r\n                this.legacySocketRemoteAddress = request.connection[\"socket\"] && request.connection[\"socket\"].remoteAddress;\r\n            }\r\n        }\r\n    }\r\n    ServerRequestParser.prototype.onError = function (error, properties, ellapsedMilliseconds) {\r\n        this._setStatus(undefined, error, properties);\r\n    };\r\n    ServerRequestParser.prototype.onResponse = function (response, properties, ellapsedMilliseconds) {\r\n        this._setStatus(response.statusCode, undefined, properties);\r\n        if (ellapsedMilliseconds) {\r\n            this.duration = ellapsedMilliseconds;\r\n        }\r\n    };\r\n    ServerRequestParser.prototype.getRequestData = function () {\r\n        var requestData = new ContractsModule.Contracts.RequestData();\r\n        requestData.id = this.requestId;\r\n        requestData.name = this.method + \" \" + url.parse(this.url).pathname;\r\n        requestData.url = this.url;\r\n        requestData.source = this.sourceIKeyHash;\r\n        requestData.duration = Util.msToTimeSpan(this.duration);\r\n        requestData.responseCode = this.statusCode ? this.statusCode.toString() : null;\r\n        requestData.success = this._isSuccess();\r\n        requestData.properties = this.properties;\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"Microsoft.ApplicationInsights.RequestData\";\r\n        data.baseData = requestData;\r\n        return data;\r\n    };\r\n    ServerRequestParser.prototype.getRequestTags = function (tags) {\r\n        // create a copy of the context for requests since client info will be used here\r\n        var newTags = {};\r\n        for (var key in tags) {\r\n            newTags[key] = tags[key];\r\n        }\r\n        // don't override tags if they are already set\r\n        newTags[ServerRequestParser.keys.locationIp] = tags[ServerRequestParser.keys.locationIp] || this._getIp();\r\n        newTags[ServerRequestParser.keys.sessionId] = tags[ServerRequestParser.keys.sessionId] || this._getId(\"ai_session\");\r\n        newTags[ServerRequestParser.keys.userId] = tags[ServerRequestParser.keys.userId] || this._getId(\"ai_user\");\r\n        newTags[ServerRequestParser.keys.userAgent] = tags[ServerRequestParser.keys.userAgent] || this.userAgent;\r\n        newTags[ServerRequestParser.keys.operationName] = this.getOperationName(tags);\r\n        newTags[ServerRequestParser.keys.operationParentId] = this.getOperationParentId(tags);\r\n        newTags[ServerRequestParser.keys.operationId] = this.getOperationId(tags);\r\n        return newTags;\r\n    };\r\n    ServerRequestParser.prototype.getOperationId = function (tags) {\r\n        return tags[ServerRequestParser.keys.operationId] || this.operationId;\r\n    };\r\n    ServerRequestParser.prototype.getOperationParentId = function (tags) {\r\n        return tags[ServerRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);\r\n    };\r\n    ServerRequestParser.prototype.getOperationName = function (tags) {\r\n        return tags[ServerRequestParser.keys.operationName] || this.method + \" \" + url.parse(this.url).pathname;\r\n    };\r\n    ServerRequestParser.prototype.getRequestId = function () {\r\n        return this.requestId;\r\n    };\r\n    ServerRequestParser.prototype._getAbsoluteUrl = function (request) {\r\n        if (!request.headers) {\r\n            return request.url;\r\n        }\r\n        var encrypted = request.connection ? request.connection.encrypted : null;\r\n        var requestUrl = url.parse(request.url);\r\n        var pathName = requestUrl.pathname;\r\n        var search = requestUrl.search;\r\n        var absoluteUrl = url.format({\r\n            protocol: encrypted ? \"https\" : \"http\",\r\n            host: request.headers.host,\r\n            pathname: pathName,\r\n            search: search\r\n        });\r\n        return absoluteUrl;\r\n    };\r\n    ServerRequestParser.prototype._getIp = function () {\r\n        // regex to match ipv4 without port\r\n        // Note: including the port would cause the payload to be rejected by the data collector\r\n        var ipMatch = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/;\r\n        var check = function (str) {\r\n            var results = ipMatch.exec(str);\r\n            if (results) {\r\n                return results[0];\r\n            }\r\n        };\r\n        var ip = check(this.rawHeaders[\"x-forwarded-for\"])\r\n            || check(this.rawHeaders[\"x-client-ip\"])\r\n            || check(this.rawHeaders[\"x-real-ip\"])\r\n            || check(this.connectionRemoteAddress)\r\n            || check(this.socketRemoteAddress)\r\n            || check(this.legacySocketRemoteAddress);\r\n        // node v12 returns this if the address is \"localhost\"\r\n        if (!ip\r\n            && this.connectionRemoteAddress\r\n            && this.connectionRemoteAddress.substr\r\n            && this.connectionRemoteAddress.substr(0, 2) === \"::\") {\r\n            ip = \"127.0.0.1\";\r\n        }\r\n        return ip;\r\n    };\r\n    ServerRequestParser.prototype._getId = function (name) {\r\n        var cookie = (this.rawHeaders && this.rawHeaders[\"cookie\"] &&\r\n            typeof this.rawHeaders[\"cookie\"] === 'string' && this.rawHeaders[\"cookie\"]) || \"\";\r\n        var value = ServerRequestParser.parseId(Util.getCookie(name, cookie));\r\n        return value;\r\n    };\r\n    ServerRequestParser.parseId = function (cookieValue) {\r\n        return cookieValue.substr(0, cookieValue.indexOf('|'));\r\n    };\r\n    ServerRequestParser.keys = new ContractsModule.Contracts.ContextTagKeys();\r\n    return ServerRequestParser;\r\n}(RequestParser));\r\nmodule.exports = ServerRequestParser;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Client.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar url = require(\"url\");\r\nvar Config = require(\"./Config\");\r\nvar Context = require(\"./Context\");\r\nvar ExceptionTracking = require(\"../AutoCollection/Exceptions\");\r\nvar ContractsModule = require(\"../Library/Contracts\");\r\nvar Channel = require(\"./Channel\");\r\nvar ServerRequestTracking = require(\"../AutoCollection/ServerRequests\");\r\nvar ClientRequestTracking = require(\"../AutoCollection/ClientRequests\");\r\nvar CorrelationContextManager_1 = require(\"../AutoCollection/CorrelationContextManager\");\r\nvar Sender = require(\"./Sender\");\r\nvar Util = require(\"./Util\");\r\nvar Logging = require(\"./Logging\");\r\nvar Client = (function () {\r\n    /**\r\n     * Constructs a new client of the client\r\n     * @param iKey the instrumentation key to use (read from environment variable if not specified)\r\n     */\r\n    function Client(iKey) {\r\n        this._telemetryProcessors = [];\r\n        var config = new Config(iKey);\r\n        this.config = config;\r\n        this.context = new Context();\r\n        this.commonProperties = {};\r\n        var sender = new Sender(function () { return config.endpointUrl; });\r\n        this.channel = new Channel(function () { return config.disableAppInsights; }, function () { return config.maxBatchSize; }, function () { return config.maxBatchIntervalMs; }, sender);\r\n    }\r\n    /**\r\n     * Log a user action or other occurrence.\r\n     * @param   name    A string to identify this event in the portal.\r\n     * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.\r\n     * @param   measurements    map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.\r\n     */\r\n    Client.prototype.trackEvent = function (name, properties, measurements) {\r\n        var event = new ContractsModule.Contracts.EventData();\r\n        event.name = name;\r\n        event.properties = properties;\r\n        event.measurements = measurements;\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"EventData\";\r\n        data.baseData = event;\r\n        this.track(data);\r\n    };\r\n    /**\r\n     * Log a trace message\r\n     * @param   message    A string to identify this event in the portal.\r\n     * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.\r\n     */\r\n    Client.prototype.trackTrace = function (message, severityLevel, properties) {\r\n        var trace = new ContractsModule.Contracts.MessageData();\r\n        trace.message = message;\r\n        trace.properties = properties;\r\n        if (!isNaN(severityLevel)) {\r\n            trace.severityLevel = severityLevel;\r\n        }\r\n        else {\r\n            trace.severityLevel = ContractsModule.Contracts.SeverityLevel.Information;\r\n        }\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"MessageData\";\r\n        data.baseData = trace;\r\n        this.track(data);\r\n    };\r\n    /**\r\n     * Log an exception you have caught.\r\n     * @param   exception   An Error from a catch clause, or the string error message.\r\n     * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.\r\n     * @param   measurements    map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.\r\n     */\r\n    Client.prototype.trackException = function (exception, properties, measurements) {\r\n        if (!Util.isError(exception)) {\r\n            exception = new Error(exception);\r\n        }\r\n        var data = ExceptionTracking.getExceptionData(exception, true, properties, measurements);\r\n        this.track(data);\r\n    };\r\n    /**\r\n     * * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.\r\n     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the\r\n     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.\r\n     *\r\n     * @param name   A string that identifies the metric.\r\n     * @param value  The value of the metric\r\n     * @param count  the number of samples used to get this value\r\n     * @param min    the min sample for this set\r\n     * @param max    the max sample for this set\r\n     * @param stdDev the standard deviation of the set\r\n     */\r\n    Client.prototype.trackMetric = function (name, value, count, min, max, stdDev, properties) {\r\n        var metrics = new ContractsModule.Contracts.MetricData(); // todo: enable client-batching of these\r\n        metrics.metrics = [];\r\n        var metric = new ContractsModule.Contracts.DataPoint();\r\n        metric.count = !isNaN(count) ? count : 1;\r\n        metric.kind = ContractsModule.Contracts.DataPointType.Aggregation;\r\n        metric.max = !isNaN(max) ? max : value;\r\n        metric.min = !isNaN(min) ? min : value;\r\n        metric.name = name;\r\n        metric.stdDev = !isNaN(stdDev) ? stdDev : 0;\r\n        metric.value = value;\r\n        metrics.metrics.push(metric);\r\n        metrics.properties = properties;\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"MetricData\";\r\n        data.baseData = metrics;\r\n        this.track(data);\r\n    };\r\n    Client.prototype.trackRequestSync = function (request, response, ellapsedMilliseconds, properties, error) {\r\n        ServerRequestTracking.trackRequestSync(this, request, response, ellapsedMilliseconds, properties, error);\r\n    };\r\n    Client.prototype.trackRequest = function (request, response, properties) {\r\n        ServerRequestTracking.trackRequest(this, request, response, properties);\r\n    };\r\n    Client.prototype.trackDependencyRequest = function (requestOptions, request, properties) {\r\n        ClientRequestTracking.trackRequest(this, requestOptions, request, properties);\r\n    };\r\n    Client.prototype.trackDependency = function (name, commandName, elapsedTimeMs, success, dependencyTypeName, properties, async, target) {\r\n        if (properties === void 0) { properties = {}; }\r\n        if (async === void 0) { async = false; }\r\n        if (target === void 0) { target = null; }\r\n        if (!target && commandName) {\r\n            target = url.parse(commandName).host;\r\n        }\r\n        var remoteDependency = new ContractsModule.Contracts.RemoteDependencyData();\r\n        remoteDependency.name = name;\r\n        remoteDependency.data = commandName;\r\n        remoteDependency.target = target;\r\n        remoteDependency.duration = Util.msToTimeSpan(elapsedTimeMs);\r\n        remoteDependency.success = success;\r\n        remoteDependency.type = dependencyTypeName;\r\n        remoteDependency.properties = properties;\r\n        var data = new ContractsModule.Contracts.Data();\r\n        data.baseType = \"RemoteDependencyData\";\r\n        data.baseData = remoteDependency;\r\n        this.track(data);\r\n    };\r\n    /**\r\n     * Immediately send all queued telemetry.\r\n     */\r\n    Client.prototype.sendPendingData = function (callback) {\r\n        this.channel.triggerSend(false, callback);\r\n    };\r\n    Client.prototype.getEnvelope = function (data, tagOverrides) {\r\n        if (data && data.baseData) {\r\n            data.baseData.ver = 2;\r\n            // if no properties are specified just add the common ones\r\n            if (!data.baseData.properties) {\r\n                data.baseData.properties = this.commonProperties;\r\n            }\r\n            else {\r\n                // otherwise, check each of the common ones\r\n                for (var name in this.commonProperties) {\r\n                    // only override if the property `name` has not been set on this item\r\n                    if (!data.baseData.properties[name]) {\r\n                        data.baseData.properties[name] = this.commonProperties[name];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // sanitize properties\r\n        data.baseData.properties = Util.validateStringMap(data.baseData.properties);\r\n        var iKey = this.config.instrumentationKey;\r\n        var envelope = new ContractsModule.Contracts.Envelope();\r\n        envelope.data = data;\r\n        envelope.iKey = iKey;\r\n        // this is kind of a hack, but the envelope name is always the same as the data name sans the chars \"data\"\r\n        envelope.name =\r\n            \"Microsoft.ApplicationInsights.\" +\r\n                iKey.replace(/-/g, \"\") +\r\n                \".\" +\r\n                data.baseType.substr(0, data.baseType.length - 4);\r\n        envelope.tags = this.getTags(tagOverrides);\r\n        envelope.time = (new Date()).toISOString();\r\n        envelope.ver = 1;\r\n        return envelope;\r\n    };\r\n    /**\r\n     * Generic track method for all telemetry types\r\n     * @param data the telemetry to send\r\n     * @param tagOverrides the context tags to use for this telemetry which overwrite default context values\r\n     */\r\n    Client.prototype.track = function (data, tagOverrides, contextObjects) {\r\n        var envelope = this.getEnvelope(data, tagOverrides);\r\n        var accepted = this.runTelemetryProcessors(envelope, contextObjects);\r\n        if (accepted) {\r\n            this.channel.send(envelope);\r\n        }\r\n    };\r\n    /**\r\n     * Adds telemetry processor to the collection. Telemetry processors will be called one by one\r\n     * before telemetry item is pushed for sending and in the order they were added.\r\n     *\r\n     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean\r\n     */\r\n    Client.prototype.addTelemetryProcessor = function (telemetryProcessor) {\r\n        this._telemetryProcessors.push(telemetryProcessor);\r\n    };\r\n    /*\r\n     * Removes all telemetry processors\r\n     */\r\n    Client.prototype.clearTelemetryProcessors = function () {\r\n        this._telemetryProcessors = [];\r\n    };\r\n    Client.prototype.runTelemetryProcessors = function (envelope, contextObjects) {\r\n        var accepted = true;\r\n        var telemetryProcessorsCount = this._telemetryProcessors.length;\r\n        if (telemetryProcessorsCount === 0) {\r\n            return accepted;\r\n        }\r\n        contextObjects = contextObjects || {};\r\n        contextObjects['correlationContext'] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        for (var i = 0; i < telemetryProcessorsCount; ++i) {\r\n            try {\r\n                var processor = this._telemetryProcessors[i];\r\n                if (processor) {\r\n                    if (processor.apply(null, [envelope, contextObjects]) === false) {\r\n                        accepted = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                accepted = false;\r\n                Logging.warn(\"One of telemetry processors failed, telemetry item will not be sent.\", error, envelope);\r\n            }\r\n        }\r\n        return accepted;\r\n    };\r\n    Client.prototype.getTags = function (tagOverrides) {\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        // Make a copy of context tags so we don't alter the actual object\r\n        // Also perform tag overriding\r\n        var newTags = {};\r\n        for (var key in this.context.tags) {\r\n            newTags[key] = this.context.tags[key];\r\n        }\r\n        for (var key in tagOverrides) {\r\n            newTags[key] = tagOverrides[key];\r\n        }\r\n        if (!correlationContext) {\r\n            return newTags;\r\n        }\r\n        // Fill in internally-populated values if not already set\r\n        if (correlationContext) {\r\n            newTags[this.context.keys.operationId] = newTags[this.context.keys.operationId] || correlationContext.operation.id;\r\n            newTags[this.context.keys.operationName] = newTags[this.context.keys.operationName] || correlationContext.operation.name;\r\n            newTags[this.context.keys.operationParentId] = newTags[this.context.keys.operationParentId] || correlationContext.operation.parentId;\r\n        }\r\n        return newTags;\r\n    };\r\n    return Client;\r\n}());\r\nmodule.exports = Client;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Config.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar crypto = require('crypto');\r\nvar Config = (function () {\r\n    function Config(instrumentationKey) {\r\n        this.instrumentationKey = instrumentationKey || Config._getInstrumentationKey();\r\n        this.instrumentationKeyHash = Config._getStringHashBase64(this.instrumentationKey);\r\n        this.endpointUrl = \"https://dc.services.visualstudio.com/v2/track\";\r\n        this.sessionRenewalMs = 30 * 60 * 1000;\r\n        this.sessionExpirationMs = 24 * 60 * 60 * 1000;\r\n        this.maxBatchSize = 250;\r\n        this.maxBatchIntervalMs = 15000;\r\n        this.disableAppInsights = false;\r\n        this.correlationHeaderExcludedDomains = [\r\n            \"*.blob.core.windows.net\",\r\n            \"*.blob.core.chinacloudapi.cn\",\r\n            \"*.blob.core.cloudapi.de\",\r\n            \"*.blob.core.usgovcloudapi.net\"];\r\n    }\r\n    Config._getInstrumentationKey = function () {\r\n        // check for both the documented env variable and the azure-prefixed variable\r\n        var iKey = process.env[Config.ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.ENV_iKey]\r\n            || process.env[Config.legacy_ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.legacy_ENV_iKey];\r\n        if (!iKey || iKey == \"\") {\r\n            throw new Error(\"Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server\");\r\n        }\r\n        return iKey;\r\n    };\r\n    Config._getStringHashBase64 = function (value) {\r\n        var hash = crypto.createHash('sha256');\r\n        hash.update(value);\r\n        var result = hash.digest('base64');\r\n        return result;\r\n    };\r\n    // Azure adds this prefix to all environment variables\r\n    Config.ENV_azurePrefix = \"APPSETTING_\";\r\n    // This key is provided in the readme\r\n    Config.ENV_iKey = \"APPINSIGHTS_INSTRUMENTATIONKEY\";\r\n    Config.legacy_ENV_iKey = \"APPINSIGHTS_INSTRUMENTATION_KEY\";\r\n    return Config;\r\n}());\r\nmodule.exports = Config;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Context.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar os = require(\"os\");\r\nvar ContractsModule = require(\"../Library/Contracts\");\r\nvar Logging = require(\"./Logging\");\r\nvar Context = (function () {\r\n    function Context(packageJsonPath) {\r\n        this.keys = new ContractsModule.Contracts.ContextTagKeys();\r\n        this.tags = {};\r\n        this._loadApplicationContext();\r\n        this._loadDeviceContext();\r\n        this._loadInternalContext();\r\n    }\r\n    Context.prototype._loadApplicationContext = function (packageJsonPath) {\r\n        var version = \"unknown\";\r\n        var description = undefined;\r\n        try {\r\n            // note: this should return the host package.json\r\n            var packageJson = require(packageJsonPath || \"../../../package.json\");\r\n            if (packageJson) {\r\n                if (typeof packageJson.version === \"string\") {\r\n                    version = packageJson.version;\r\n                }\r\n                if (typeof packageJson.description === \"string\") {\r\n                    description = packageJson.description;\r\n                }\r\n            }\r\n        }\r\n        catch (exception) {\r\n            Logging.info(\"unable to read app version: \", exception);\r\n        }\r\n        this.tags[this.keys.applicationVersion] = version;\r\n        // TODO: consider sending it as a custom property\r\n        //if(description) {\r\n        //    this.tags[this.keys.applicationBuild] = description;\r\n        //}\r\n    };\r\n    Context.prototype._loadDeviceContext = function () {\r\n        this.tags[this.keys.deviceId] = \"\";\r\n        this.tags[this.keys.cloudRoleInstance] = os && os.hostname();\r\n        this.tags[this.keys.deviceOSVersion] = os && os.type() + \" \" + os && os.release();\r\n        // not yet supported tags\r\n        this.tags[\"ai.device.osArchitecture\"] = os && os.arch();\r\n        this.tags[\"ai.device.osPlatform\"] = os && os.platform();\r\n    };\r\n    Context.prototype._loadInternalContext = function () {\r\n        var version = \"unknown\";\r\n        try {\r\n            // note: this should return the appInsights package.json\r\n            var packageJson = require(\"../package.json\");\r\n            if (packageJson && typeof packageJson.version === \"string\") {\r\n                version = packageJson.version;\r\n            }\r\n        }\r\n        catch (exception) {\r\n            Logging.info(\"unable to read SDK version: \" + exception);\r\n        }\r\n        this.tags[this.keys.internalSdkVersion] = \"node:\" + version || \"unknown\";\r\n    };\r\n    return Context;\r\n}());\r\nmodule.exports = Context;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Channel.js":"\"use strict\";\r\nvar Logging = require(\"./Logging\");\r\nvar Channel = (function () {\r\n    function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {\r\n        this._buffer = [];\r\n        this._lastSend = 0;\r\n        this._isDisabled = isDisabled;\r\n        this._getBatchSize = getBatchSize;\r\n        this._getBatchIntervalMs = getBatchIntervalMs;\r\n        this._sender = sender;\r\n    }\r\n    /**\r\n     * Enable or disable offline mode\r\n     */\r\n    Channel.prototype.setOfflineMode = function (value, resendInterval) {\r\n        this._sender.setOfflineMode(value, resendInterval);\r\n    };\r\n    /**\r\n     * Add a telemetry item to the send buffer\r\n     */\r\n    Channel.prototype.send = function (envelope) {\r\n        var _this = this;\r\n        // if master off switch is set, don't send any data\r\n        if (this._isDisabled()) {\r\n            // Do not send/save data\r\n            return;\r\n        }\r\n        // validate input\r\n        if (!envelope) {\r\n            Logging.warn(\"Cannot send null/undefined telemetry\");\r\n            return;\r\n        }\r\n        // check if the incoming payload is too large, truncate if necessary\r\n        var payload = this._stringify(envelope);\r\n        if (typeof payload !== \"string\") {\r\n            return;\r\n        }\r\n        // enqueue the payload\r\n        this._buffer.push(payload);\r\n        // flush if we would exceed the max-size limit by adding this item\r\n        if (this._buffer.length >= this._getBatchSize()) {\r\n            this.triggerSend(false);\r\n            return;\r\n        }\r\n        // ensure an invocation timeout is set if anything is in the buffer\r\n        if (!this._timeoutHandle && this._buffer.length > 0) {\r\n            this._timeoutHandle = setTimeout(function () {\r\n                _this._timeoutHandle = null;\r\n                _this.triggerSend(false);\r\n            }, this._getBatchIntervalMs());\r\n        }\r\n    };\r\n    Channel.prototype.handleCrash = function (envelope) {\r\n        if (envelope) {\r\n            var payload = this._stringify(envelope);\r\n            if (typeof payload === \"string\") {\r\n                this._buffer.push(payload);\r\n                this.triggerSend(true);\r\n            }\r\n            else {\r\n                Logging.warn(\"Could not send crash\", envelope);\r\n            }\r\n        }\r\n        else {\r\n            Logging.warn(\"handleCrash was called with empty payload\", envelope);\r\n        }\r\n    };\r\n    /**\r\n     * Immediately send buffered data\r\n     */\r\n    Channel.prototype.triggerSend = function (isNodeCrashing, callback) {\r\n        var bufferIsEmpty = this._buffer.length < 1;\r\n        if (!bufferIsEmpty) {\r\n            // compose an array of payloads\r\n            var batch = this._buffer.join(\"\\n\");\r\n            // invoke send\r\n            if (isNodeCrashing) {\r\n                this._sender.saveOnCrash(batch);\r\n                if (typeof callback === \"function\") {\r\n                    callback(\"data saved on crash\");\r\n                }\r\n            }\r\n            else {\r\n                this._sender.send(new Buffer(batch), callback);\r\n            }\r\n        }\r\n        // update lastSend time to enable throttling\r\n        this._lastSend = +new Date;\r\n        // clear buffer\r\n        this._buffer.length = 0;\r\n        clearTimeout(this._timeoutHandle);\r\n        this._timeoutHandle = null;\r\n        if (bufferIsEmpty && typeof callback === \"function\") {\r\n            callback(\"no data to send\");\r\n        }\r\n    };\r\n    Channel.prototype._stringify = function (envelope) {\r\n        try {\r\n            return JSON.stringify(envelope);\r\n        }\r\n        catch (error) {\r\n            Logging.warn(\"Failed to serialize payload\", error, envelope);\r\n        }\r\n    };\r\n    return Channel;\r\n}());\r\nmodule.exports = Channel;\r\n","/home/travis/build/npmtest/node-npmtest-applicationinsights/node_modules/applicationinsights/Library/Sender.js":"///<reference path=\"..\\typings\\globals\\node\\index.d.ts\" />\r\n\"use strict\";\r\nvar fs = require(\"fs\");\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar os = require(\"os\");\r\nvar path = require(\"path\");\r\nvar url = require(\"url\");\r\nvar zlib = require(\"zlib\");\r\nvar Logging = require(\"./Logging\");\r\nvar AutoCollectClientRequests = require(\"../AutoCollection/ClientRequests\");\r\nvar Sender = (function () {\r\n    function Sender(getUrl, onSuccess, onError) {\r\n        this._getUrl = getUrl;\r\n        this._onSuccess = onSuccess;\r\n        this._onError = onError;\r\n        this._enableOfflineMode = false;\r\n        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;\r\n    }\r\n    /**\r\n    * Enable or disable offline mode\r\n    */\r\n    Sender.prototype.setOfflineMode = function (value, resendInterval) {\r\n        this._enableOfflineMode = value;\r\n        if (typeof resendInterval === 'number' && resendInterval >= 0) {\r\n            this._resendInterval = Math.floor(resendInterval);\r\n        }\r\n    };\r\n    Sender.prototype.send = function (payload, callback) {\r\n        var _this = this;\r\n        var endpointUrl = this._getUrl();\r\n        if (endpointUrl && endpointUrl.indexOf(\"//\") === 0) {\r\n            // use https if the config did not specify a protocol\r\n            endpointUrl = \"https:\" + endpointUrl;\r\n        }\r\n        // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent\r\n        var parsedUrl = url.parse(endpointUrl);\r\n        var options = {\r\n            host: parsedUrl.hostname,\r\n            port: parsedUrl.port,\r\n            path: parsedUrl.pathname,\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application/x-json-stream\"\r\n            }\r\n        };\r\n        zlib.gzip(payload, function (err, buffer) {\r\n            var dataToSend = buffer;\r\n            if (err) {\r\n                Logging.warn(err);\r\n                dataToSend = payload; // something went wrong so send without gzip\r\n                options.headers[\"Content-Length\"] = payload.length;\r\n            }\r\n            else {\r\n                options.headers[\"Content-Encoding\"] = \"gzip\";\r\n                options.headers[\"Content-Length\"] = buffer.length;\r\n            }\r\n            Logging.info(Sender.TAG, options);\r\n            // Ensure this request is not captured by auto-collection.\r\n            options[AutoCollectClientRequests.disableCollectionRequestOption] = true;\r\n            var requestCallback = function (res) {\r\n                res.setEncoding(\"utf-8\");\r\n                //returns empty if the data is accepted\r\n                var responseString = \"\";\r\n                res.on(\"data\", function (data) {\r\n                    responseString += data;\r\n                });\r\n                res.on(\"end\", function () {\r\n                    Logging.info(Sender.TAG, responseString);\r\n                    if (typeof _this._onSuccess === \"function\") {\r\n                        _this._onSuccess(responseString);\r\n                    }\r\n                    if (typeof callback === \"function\") {\r\n                        callback(responseString);\r\n                    }\r\n                    if (_this._enableOfflineMode) {\r\n                        // try to send any cached events if the user is back online\r\n                        if (res.statusCode === 200) {\r\n                            setTimeout(function () { return _this._sendFirstFileOnDisk(); }, _this._resendInterval);\r\n                        }\r\n                        else if (res.statusCode === 206 ||\r\n                            res.statusCode === 429 ||\r\n                            res.statusCode === 439) {\r\n                            _this._storeToDisk(payload);\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            var req = (parsedUrl.protocol == \"https:\") ?\r\n                https.request(options, requestCallback) :\r\n                http.request(options, requestCallback);\r\n            req.on(\"error\", function (error) {\r\n                // todo: handle error codes better (group to recoverable/non-recoverable and persist)\r\n                Logging.warn(Sender.TAG, error);\r\n                _this._onErrorHelper(error);\r\n                if (typeof callback === \"function\") {\r\n                    var errorMessage = \"error sending telemetry\";\r\n                    if (error && (typeof error.toString === \"function\")) {\r\n                        errorMessage = error.toString();\r\n                    }\r\n                    callback(errorMessage);\r\n                }\r\n                if (_this._enableOfflineMode) {\r\n                    _this._storeToDisk(payload);\r\n                }\r\n            });\r\n            req.write(dataToSend);\r\n            req.end();\r\n        });\r\n    };\r\n    Sender.prototype.saveOnCrash = function (payload) {\r\n        this._storeToDiskSync(payload);\r\n    };\r\n    Sender.prototype._confirmDirExists = function (direcotry, callback) {\r\n        fs.exists(direcotry, function (exists) {\r\n            if (!exists) {\r\n                fs.mkdir(direcotry, function (err) {\r\n                    callback(err);\r\n                });\r\n            }\r\n            else {\r\n                callback(null);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk in the temp direcotry\r\n     */\r\n    Sender.prototype._storeToDisk = function (payload) {\r\n        var _this = this;\r\n        //ensure directory is created\r\n        var direcotry = path.join(os.tmpdir(), Sender.TEMPDIR);\r\n        this._confirmDirExists(direcotry, function (error) {\r\n            if (error) {\r\n                _this._onErrorHelper(error);\r\n                return;\r\n            }\r\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n            //would require an external dependency\r\n            var fileName = new Date().getTime() + \".ai.json\";\r\n            var fileFullPath = path.join(direcotry, fileName);\r\n            Logging.info(Sender.TAG, \"saving data to disk at: \" + fileFullPath);\r\n            fs.writeFile(fileFullPath, payload, function (error) { return _this._onErrorHelper(error); });\r\n        });\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk using sync file operations\r\n     * this is used when storing data before crashes\r\n     */\r\n    Sender.prototype._storeToDiskSync = function (payload) {\r\n        var direcotry = path.join(os.tmpdir(), Sender.TEMPDIR);\r\n        try {\r\n            if (!fs.existsSync(direcotry)) {\r\n                fs.mkdirSync(direcotry);\r\n            }\r\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n            //would require an external dependency\r\n            var fileName = new Date().getTime() + \".ai.json\";\r\n            var fileFullPath = path.join(direcotry, fileName);\r\n            Logging.info(Sender.TAG, \"saving data before crash to disk at: \" + fileFullPath);\r\n            fs.writeFileSync(fileFullPath, payload);\r\n        }\r\n        catch (error) {\r\n            this._onErrorHelper(error);\r\n        }\r\n    };\r\n    /**\r\n     * Check for temp telemetry files\r\n     * reads the first file if exist, deletes it and tries to send its load\r\n     */\r\n    Sender.prototype._sendFirstFileOnDisk = function () {\r\n        var _this = this;\r\n        var tempDir = path.join(os.tmpdir(), Sender.TEMPDIR);\r\n        fs.exists(tempDir, function (exists) {\r\n            if (exists) {\r\n                fs.readdir(tempDir, function (error, files) {\r\n                    if (!error) {\r\n                        files = files.filter(function (f) { return path.basename(f).indexOf(\".ai.json\") > -1; });\r\n                        if (files.length > 0) {\r\n                            var firstFile = files[0];\r\n                            var filePath = path.join(tempDir, firstFile);\r\n                            fs.readFile(filePath, function (error, payload) {\r\n                                if (!error) {\r\n                                    // delete the file first to prevent double sending\r\n                                    fs.unlink(filePath, function (error) {\r\n                                        if (!error) {\r\n                                            _this.send(payload);\r\n                                        }\r\n                                        else {\r\n                                            _this._onErrorHelper(error);\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    _this._onErrorHelper(error);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        _this._onErrorHelper(error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    Sender.prototype._onErrorHelper = function (error) {\r\n        if (typeof this._onError === \"function\") {\r\n            this._onError(error);\r\n        }\r\n    };\r\n    Sender.TAG = \"Sender\";\r\n    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throtelling from the service side\r\n    Sender.WAIT_BETWEEN_RESEND = 60 * 1000;\r\n    Sender.TEMPDIR = \"appInsights-node\";\r\n    return Sender;\r\n}());\r\nmodule.exports = Sender;\r\n"}